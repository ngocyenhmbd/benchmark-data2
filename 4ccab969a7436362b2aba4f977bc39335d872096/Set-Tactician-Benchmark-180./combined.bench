coq-tactician-stdlib.8.11.dev	Coq.Arith.PeanoNat.Nat.bi_induction	180	3.042089	1	2	0	synth with cache (only 1: refine (fun (v0 : forall v1 : @nat, Prop) (v1 : Proper (eq ==> @iff) v0) (v2 : v0 0) (v3 : forall v4 : @nat, v0 v4 <-> v0 (S v4)) => nat_ind v0 v2 (fun (v4 : @nat) (v5 : v0 v4) => let v6 : forall v7 : @nat, v0 v7 <-> v0 (S v7) := v3 in let v7 : @nat := v4 in let v8 : v0 v7 <-> v0 (S v7) := v6 v7 in match v8 as v9 in (_ /\ _) return (v0 (S v4)) with | conj v9 v10 => (fun (v9 : forall v10 : v0 v4, v0 (S v4)) (v10 : forall v11 : v0 (S v4), v0 v4) => v9 v5) v9 v10 end))).
coq-tactician-stdlib.8.11.dev	Coq.Arith.PeanoNat.Nat.recursion_wd	180	2.938317	2	3	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 : Type) (v1 : relation v0) => (fun (v2 v3 : v0) (v4 : v1 v2 v3) => (fun (v5 : forall (v6 : @nat) (v7 : v0), v0) (v6 : forall (v7 : @nat) (v8 : v0), v0) (v7 : (eq ==> v1 ==> v1)%signature v5 v6) => (fun (v8 v9 : @nat) (v10 : v8 = v9) => eq_ind v8 (fun v11 : @nat => v1 (recursion v2 v5 v8) (recursion v3 v6 v11)) (nat_ind (fun v11 : @nat => v1 (recursion v2 v5 v11) (recursion v3 v6 v11)) (v4 : v1 (recursion v2 v5 0) (recursion v3 v6 0)) (fun (v11 : @nat) (v12 : v1 (recursion v2 v5 v11) (recursion v3 v6 v11)) => v7 v11 v11 eq_refl (recursion v2 v5 v11) (recursion v3 v6 v11) v12 : v1 (recursion v2 v5 (S v11)) (recursion v3 v6 (S v11))) v8) v9 v10) : (eq ==> v1)%signature (recursion v2 v5) (recursion v3 v6)) : ((eq ==> v1 ==> v1) ==> eq ==> v1)%signature (recursion v2) (recursion v3)) : Proper (v1 ==> (eq ==> v1 ==> v1) ==> eq ==> v1) recursion)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.PeanoNat.Nat.recursion_0	180	3.033417	1	2	0	synth with cache (only 1: refine (fun (v0 : Type) (v1 : v0) (v2 : forall (v3 : @nat) (v4 : v0), v0) => eq_refl)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.PeanoNat.Nat.recursion_succ	180	3.266930	1	2	0	synth with cache (only 1: refine (((fun (v0 : Type) (v1 : relation v0) (v2 : v0) (v3 : forall (v4 : @nat) (v5 : v0), v0) (v4 : v1 v2 v2) (v5 : forall (v6 v7 : @nat) (v8 : v6 = v7) (v9 v10 : v0) (v11 : v1 v9 v10), v1 (v3 v6 v9) (v3 v7 v10)) (v6 : @nat) => nat_ind (fun v7 : @nat => v1 (recursion v2 v3 (S v7)) (v3 v7 (recursion v2 v3 v7))) (v5 0 0 eq_refl v2 v2 v4 : v1 (recursion v2 v3 1) (v3 0 (recursion v2 v3 0))) (fun (v7 : @nat) (v8 : v1 (recursion v2 v3 (S v7)) (v3 v7 (recursion v2 v3 v7))) => v5 (S v7) (S v7) eq_refl (v3 v7 (recursion v2 v3 v7)) (v3 v7 (recursion v2 v3 v7)) v8 : v1 (recursion v2 v3 (S (S v7))) (v3 (S v7) (recursion v2 v3 (S v7)))) v6) : forall (v0 : Type) (v1 : relation v0) (v2 : v0) (v3 : forall (v4 : @nat) (v5 : v0), v0) (v4 : v1 v2 v2) (v5 : (eq ==> v1 ==> v1)%signature v3 v3) (v6 : @nat), v1 (recursion v2 v3 (S v6)) (v3 v6 (recursion v2 v3 v6))) : forall (v0 : Type) (v1 : relation v0) (v2 : v0) (v3 : forall (v4 : @nat) (v5 : v0), v0) (v4 : v1 v2 v2) (v5 : Proper (eq ==> v1 ==> v1) v3) (v6 : @nat), v1 (recursion v2 v3 (S v6)) (v3 v6 (recursion v2 v3 v6)))).
coq-tactician-stdlib.8.11.dev	Coq.Arith.PeanoNat.Nat.pred_succ	180	3.195539	2	3	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @nat => eq_refl)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.PeanoNat.Nat.pred_0	180	3.221543	1	2	0	synth with cache (only 1: refine eq_refl).
coq-tactician-stdlib.8.11.dev	Coq.Arith.PeanoNat.Nat.one_succ	180	3.249575	1	2	0	synth with cache (only 1: refine eq_refl).
coq-tactician-stdlib.8.11.dev	Coq.Arith.PeanoNat.Nat.two_succ	180	3.270597	1	2	0	synth with cache (only 1: refine eq_refl).
coq-tactician-stdlib.8.11.dev	Coq.Arith.PeanoNat.Nat.add_0_l	180	3.302978	2	3	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @nat => eq_refl)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.PeanoNat.Nat.add_succ_l	180	3.428686	2	3	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => eq_refl)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.PeanoNat.Nat.sub_0_r	180	3.376702	2	3	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @nat => match v0 as v1 in nat return (v1 - 0 = v1) with | 0 => eq_refl | S v1 => (fun v1 : @nat => eq_refl) v1 end)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.PeanoNat.Nat.sub_succ_r	180	3.251567	2	3	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => nat_ind (fun v2 : @nat => forall v3 : @nat, v2 - S v3 = Init.Nat.pred (v2 - v3)) (fun v2 : @nat => match v2 as v3 in nat return (0 - S v3 = Init.Nat.pred (0 - v3)) with | 0 => eq_refl : 0 - 1 = Init.Nat.pred (0 - 0) | S v3 => (fun v3 : @nat => eq_refl : 0 - S (S v3) = Init.Nat.pred (0 - S v3)) v3 end) (fun (v2 : @nat) (v3 : forall v4 : @nat, v2 - S v4 = Init.Nat.pred (v2 - v4)) (v4 : @nat) => match v4 as v5 in nat return (S v2 - S v5 = Init.Nat.pred (S v2 - v5)) with | 0 => sub_0_r v2 : S v2 - 1 = Init.Nat.pred (S v2 - 0) | S v5 => (fun v5 : @nat => v3 v5 : S v2 - S (S v5) = Init.Nat.pred (S v2 - S v5)) v5 end) v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.PeanoNat.Nat.mul_0_l	180	3.270481	2	3	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @nat => eq_refl)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.PeanoNat.Nat.mul_succ_l	180	3.351398	2	3	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => let v2 : forall v3 v4 : @nat, v3 + S v4 = S (v3 + v4) := fun v3 : @nat => nat_ind (fun v4 : @nat => forall v5 : @nat, v4 + S v5 = S (v4 + v5)) (fun v4 : @nat => eq_refl) (fun (v4 : @nat) (v5 : forall v6 : @nat, v4 + S v6 = S (v4 + v6)) (v6 : @nat) => eq_sym (plus_n_Sm (S v4) v6)) v3 in let v3 : forall v4 v5 : @nat, v4 + v5 = v5 + v4 := fun v4 : @nat => nat_ind (fun v5 : @nat => forall v6 : @nat, v5 + v6 = v6 + v5) ((fun v5 : @nat => plus_n_O v5) : forall v5 : @nat, 0 + v5 = v5 + 0) (fun (v5 : @nat) (v6 : forall v7 : @nat, v5 + v7 = v7 + v5) => (fun v7 : @nat => eq_ind_r (fun v8 : @nat => S (v5 + v7) = v8) (let v8 : v5 + v7 = v7 + v5 := v6 v7 in (fun v9 : v5 + v7 = v7 + v5 => eq_trans (f_equal (fun v10 : forall v11 : @nat, @nat => v10 (v5 + v7)) eq_refl) (f_equal (@S) v9)) v8) (v2 v7 v5)) : forall v7 : @nat, S v5 + v7 = v7 + S v5) v4 in eq_ind_r (fun v4 : @nat => S v0 * v1 = v4) eq_refl (v3 (v0 * v1) v1))).
coq-tactician-stdlib.8.11.dev	Coq.Arith.PeanoNat.Nat.lt_succ_r	180	3.358221	2	3	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => conj (le_S_n v0 v1) (fun v2 : v0 <= v1 => le_ind v0 (fun v3 : @nat => v0 < S v3) (le_n (S v0) : v0 < S v0) (fun (v3 : @nat) (v4 : v0 <= v3) (v5 : v0 < S v3) => le_S (S v0) (S v3) v5 : v0 < S (S v3)) v1 v2))).
coq-tactician-stdlib.8.11.dev	Coq.Arith.PeanoNat.Nat.eqb_eq	180	3.361816	2	3	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => nat_ind (fun v2 : @nat => forall v3 : @nat, (v2 =? v3) = @true <-> v2 = v3) (fun v2 : @nat => match v2 as v3 in nat return ((0 =? v3) = @true <-> 0 = v3) with | 0 => conj (fun v3 : @true = @true => eq_refl) (fun v3 : 0 = 0 => eq_refl) : (0 =? 0) = @true <-> 0 = 0 | S v3 => (fun v3 : @nat => conj (fun v4 : @false = @true => let v5 : forall v6 : @true = @true, 0 = S v3 := match v4 as v7 in (_ = v6) return (forall v8 : v6 = @true, 0 = S v3) with | eq_refl => fun v6 : @false = @true => (fun v7 : @false = @true => let v8 : @False := eq_ind (@false) (fun v9 : @bool => match v9 as v10 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v7 in False_ind (0 = S v3) v8) v6 end in v5 eq_refl) (fun v4 : 0 = S v3 => let v5 : forall v6 : S v3 = S v3, @false = @true := match v4 as v7 in (_ = v6) return (forall v8 : v6 = S v3, @false = @true) with | eq_refl => fun v6 : 0 = S v3 => (fun v7 : 0 = S v3 => let v8 : @False := eq_ind 0 (fun v9 : @nat => match v9 as v10 in nat return Prop with | 0 => @True | S v10 => (fun v10 : @nat => @False) v10 end) (@I) (S v3) v7 in False_ind (@false = @true) v8) v6 end in v5 eq_refl) : (0 =? S v3) = @true <-> 0 = S v3) v3 end) (fun (v2 : @nat) (v3 : forall v4 : @nat, (v2 =? v4) = @true <-> v2 = v4) (v4 : @nat) => match v4 as v5 in nat return ((S v2 =? v5) = @true <-> S v2 = v5) with | 0 => conj (fun v5 : @false = @true => let v6 : forall v7 : @true = @true, S v2 = 0 := match v5 as v8 in (_ = v7) return (forall v9 : v7 = @true, S v2 = 0) with | eq_refl => fun v7 : @false = @true => (fun v8 : @false = @true => let v9 : @False := eq_ind (@false) (fun v10 : @bool => match v10 as v11 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v8 in False_ind (S v2 = 0) v9) v7 end in v6 eq_refl) (fun v5 : S v2 = 0 => let v6 : forall v7 : 0 = 0, @false = @true := match v5 as v8 in (_ = v7) return (forall v9 : v7 = 0, @false = @true) with | eq_refl => fun v7 : S v2 = 0 => (fun v8 : S v2 = 0 => let v9 : @False := eq_ind (S v2) (fun v10 : @nat => match v10 as v11 in nat return Prop with | 0 => @False | S v11 => (fun v11 : @nat => @True) v11 end) (@I) 0 v8 in False_ind (@false = @true) v9) v7 end in v6 eq_refl) : (S v2 =? 0) = @true <-> S v2 = 0 | S v5 => (fun v5 : @nat => (fun v6 : (v2 =? v5) = @true <-> v2 = v5 => trans_co_eq_inv_impl_morphism (@iff_Transitive) ((v2 =? v5) = @true) (v2 = v5) v6 (S v2 = S v5) (S v2 = S v5) (eq_proper_proxy (S v2 = S v5))) (v3 v5) (conj (fun v6 : v2 = v5 => eq_ind_r (fun v7 : @nat => forall v8 : forall v9 : @nat, (v7 =? v9) = @true <-> v7 = v9, S v7 = S v5) (fun v7 : forall v8 : @nat, (v5 =? v8) = @true <-> v5 = v8 => eq_refl) v6 v3) (fun v6 : S v2 = S v5 => let v7 : v2 = v5 := f_equal (fun v8 : @nat => match v8 as v9 in nat return (@nat) with | 0 => v2 | S v9 => (fun v9 : @nat => v9) v9 end) v6 in (fun v8 : v2 = v5 => v8) v7)) : (S v2 =? S v5) = @true <-> S v2 = S v5) v5 end) v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.PeanoNat.Nat.leb_le	180	3.379462	2	3	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => nat_ind (fun v2 : @nat => forall v3 : @nat, (v2 <=? v3) = @true <-> v2 <= v3) (fun v2 : @nat => match v2 as v3 in nat return ((0 <=? v3) = @true <-> 0 <= v3) with | 0 => conj (fun v3 : @true = @true => le_n 0) (fun v3 : 0 <= 0 => eq_refl) : (0 <=? 0) = @true <-> 0 <= 0 | S v3 => (fun v3 : @nat => conj (fun v4 : @true = @true => le_0_n (S v3)) (fun v4 : 0 <= S v3 => eq_refl) : (0 <=? S v3) = @true <-> 0 <= S v3) v3 end) (fun (v2 : @nat) (v3 : forall v4 : @nat, (v2 <=? v4) = @true <-> v2 <= v4) (v4 : @nat) => match v4 as v5 in nat return ((S v2 <=? v5) = @true <-> S v2 <= v5) with | 0 => conj (fun v5 : @false = @true => let v6 : forall v7 : @true = @true, S v2 <= 0 := match v5 as v8 in (_ = v7) return (forall v9 : v7 = @true, S v2 <= 0) with | eq_refl => fun v7 : @false = @true => (fun v8 : @false = @true => let v9 : @False := eq_ind (@false) (fun v10 : @bool => match v10 as v11 in bool return Prop with | true => @False | false => @True end) (@I) (@true) v8 in False_ind (S v2 <= 0) v9) v7 end in v6 eq_refl) (fun v5 : S v2 <= 0 => let v6 : forall v7 : 0 = 0, @false = @true := match v5 as v8 in (_ <= v7) return (forall v9 : v7 = 0, @false = @true) with | le_n _ => fun v7 : S v2 = 0 => (fun v8 : S v2 = 0 => let v9 : @False := eq_ind (S v2) (fun v10 : @nat => match v10 as v11 in nat return Prop with | 0 => @False | S v11 => (fun v11 : @nat => @True) v11 end) (@I) 0 v8 in False_ind (@false = @true) v9) v7 | le_S _ v7 v8 => (fun (v7 : @nat) (v8 : S v2 <= v7) (v9 : S v7 = 0) => (fun v10 : S v7 = 0 => let v11 : @False := eq_ind (S v7) (fun v12 : @nat => match v12 as v13 in nat return Prop with | 0 => @False | S v13 => (fun v13 : @nat => @True) v13 end) (@I) 0 v10 in False_ind (forall v12 : S v2 <= v7, @false = @true) v11) v9 v8) v7 v8 end in v6 eq_refl) : (S v2 <=? 0) = @true <-> S v2 <= 0 | S v5 => (fun v5 : @nat => (fun v6 : (v2 <=? v5) = @true <-> v2 <= v5 => trans_co_eq_inv_impl_morphism (@iff_Transitive) ((v2 <=? v5) = @true) (v2 <= v5) v6 (S v2 <= S v5) (S v2 <= S v5) (eq_proper_proxy (S v2 <= S v5))) (v3 v5) (conj (le_n_S v2 v5) (le_S_n v2 v5)) : (S v2 <=? S v5) = @true <-> S v2 <= S v5) v5 end) v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.PeanoNat.Nat.ltb_lt	180	3.409587	2	3	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => leb_le (S v0) v1)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.PeanoNat.Nat.compare_eq_iff	180	3.491263	2	3	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => nat_ind (fun v2 : @nat => forall v3 : @nat, (v2 ?= v3) = @Eq <-> v2 = v3) (fun v2 : @nat => match v2 as v3 in nat return ((0 ?= v3) = @Eq <-> 0 = v3) with | 0 => conj (fun v3 : @Eq = @Eq => eq_refl) (fun v3 : 0 = 0 => eq_refl) : (0 ?= 0) = @Eq <-> 0 = 0 | S v3 => (fun v3 : @nat => conj (fun v4 : @Lt = @Eq => let v5 : forall v6 : @Eq = @Eq, 0 = S v3 := match v4 as v7 in (_ = v6) return (forall v8 : v6 = @Eq, 0 = S v3) with | eq_refl => fun v6 : @Lt = @Eq => (fun v7 : @Lt = @Eq => let v8 : @False := eq_ind (@Lt) (fun v9 : @comparison => match v9 as v10 in comparison return Prop with | Lt => @True | _ => @False end) (@I) (@Eq) v7 in False_ind (0 = S v3) v8) v6 end in v5 eq_refl) (fun v4 : 0 = S v3 => let v5 : forall v6 : S v3 = S v3, @Lt = @Eq := match v4 as v7 in (_ = v6) return (forall v8 : v6 = S v3, @Lt = @Eq) with | eq_refl => fun v6 : 0 = S v3 => (fun v7 : 0 = S v3 => let v8 : @False := eq_ind 0 (fun v9 : @nat => match v9 as v10 in nat return Prop with | 0 => @True | S v10 => (fun v10 : @nat => @False) v10 end) (@I) (S v3) v7 in False_ind (@Lt = @Eq) v8) v6 end in v5 eq_refl) : (0 ?= S v3) = @Eq <-> 0 = S v3) v3 end) (fun (v2 : @nat) (v3 : forall v4 : @nat, (v2 ?= v4) = @Eq <-> v2 = v4) (v4 : @nat) => match v4 as v5 in nat return ((S v2 ?= v5) = @Eq <-> S v2 = v5) with | 0 => conj (fun v5 : @Gt = @Eq => let v6 : forall v7 : @Eq = @Eq, S v2 = 0 := match v5 as v8 in (_ = v7) return (forall v9 : v7 = @Eq, S v2 = 0) with | eq_refl => fun v7 : @Gt = @Eq => (fun v8 : @Gt = @Eq => let v9 : @False := eq_ind (@Gt) (fun v10 : @comparison => match v10 as v11 in comparison return Prop with | Gt => @True | _ => @False end) (@I) (@Eq) v8 in False_ind (S v2 = 0) v9) v7 end in v6 eq_refl) (fun v5 : S v2 = 0 => let v6 : forall v7 : 0 = 0, @Gt = @Eq := match v5 as v8 in (_ = v7) return (forall v9 : v7 = 0, @Gt = @Eq) with | eq_refl => fun v7 : S v2 = 0 => (fun v8 : S v2 = 0 => let v9 : @False := eq_ind (S v2) (fun v10 : @nat => match v10 as v11 in nat return Prop with | 0 => @False | S v11 => (fun v11 : @nat => @True) v11 end) (@I) 0 v8 in False_ind (@Gt = @Eq) v9) v7 end in v6 eq_refl) : (S v2 ?= 0) = @Eq <-> S v2 = 0 | S v5 => (fun v5 : @nat => (fun v6 : (v2 ?= v5) = @Eq <-> v2 = v5 => trans_co_eq_inv_impl_morphism (@iff_Transitive) ((v2 ?= v5) = @Eq) (v2 = v5) v6 (S v2 = S v5) (S v2 = S v5) (eq_proper_proxy (S v2 = S v5))) (v3 v5) (conj (fun v6 : v2 = v5 => f_equal_nat (@nat) (@S) v2 v5 v6) (fun v6 : S v2 = S v5 => eq_add_S v2 v5 v6)) : (S v2 ?= S v5) = @Eq <-> S v2 = S v5) v5 end) v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.PeanoNat.Nat.compare_lt_iff	180	3.280587	2	3	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => nat_ind (fun v2 : @nat => forall v3 : @nat, (v2 ?= v3) = @Lt <-> v2 < v3) (fun v2 : @nat => match v2 as v3 in nat return ((0 ?= v3) = @Lt <-> 0 < v3) with | 0 => conj (fun v3 : @Eq = @Lt => let v4 : forall v5 : @Lt = @Lt, 0 < 0 := match v3 as v6 in (_ = v5) return (forall v7 : v5 = @Lt, 0 < 0) with | eq_refl => fun v5 : @Eq = @Lt => (fun v6 : @Eq = @Lt => let v7 : @False := eq_ind (@Eq) (fun v8 : @comparison => match v8 as v9 in comparison return Prop with | Eq => @True | _ => @False end) (@I) (@Lt) v6 in False_ind (0 < 0) v7) v5 end in v4 eq_refl) (fun v3 : 0 < 0 => let v4 : forall v5 : 0 = 0, @Eq = @Lt := match v3 as v6 in (_ <= v5) return (forall v7 : v5 = 0, @Eq = @Lt) with | le_n _ => fun v5 : 1 = 0 => (fun v6 : 1 = 0 => let v7 : @False := eq_ind 1 (fun v8 : @nat => match v8 as v9 in nat return Prop with | 0 => @False | S v9 => (fun v9 : @nat => @True) v9 end) (@I) 0 v6 in False_ind (@Eq = @Lt) v7) v5 | le_S _ v5 v6 => (fun (v5 : @nat) (v6 : 1 <= v5) (v7 : S v5 = 0) => (fun v8 : S v5 = 0 => let v9 : @False := eq_ind (S v5) (fun v10 : @nat => match v10 as v11 in nat return Prop with | 0 => @False | S v11 => (fun v11 : @nat => @True) v11 end) (@I) 0 v8 in False_ind (forall v10 : 1 <= v5, @Eq = @Lt) v9) v7 v6) v5 v6 end in v4 eq_refl) : (0 ?= 0) = @Lt <-> 0 < 0 | S v3 => (fun v3 : @nat => conj (fun v4 : @Lt = @Lt => le_n_S 0 v3 (le_0_n v3)) (fun v4 : 0 < S v3 => eq_refl) : (0 ?= S v3) = @Lt <-> 0 < S v3) v3 end) (fun (v2 : @nat) (v3 : forall v4 : @nat, (v2 ?= v4) = @Lt <-> v2 < v4) (v4 : @nat) => match v4 as v5 in nat return ((S v2 ?= v5) = @Lt <-> S v2 < v5) with | 0 => conj (fun v5 : @Gt = @Lt => let v6 : forall v7 : @Lt = @Lt, S v2 < 0 := match v5 as v8 in (_ = v7) return (forall v9 : v7 = @Lt, S v2 < 0) with | eq_refl => fun v7 : @Gt = @Lt => (fun v8 : @Gt = @Lt => let v9 : @False := eq_ind (@Gt) (fun v10 : @comparison => match v10 as v11 in comparison return Prop with | Gt => @True | _ => @False end) (@I) (@Lt) v8 in False_ind (S v2 < 0) v9) v7 end in v6 eq_refl) (fun v5 : S v2 < 0 => let v6 : forall v7 : 0 = 0, @Gt = @Lt := match v5 as v8 in (_ <= v7) return (forall v9 : v7 = 0, @Gt = @Lt) with | le_n _ => fun v7 : S (S v2) = 0 => (fun v8 : S (S v2) = 0 => let v9 : @False := eq_ind (S (S v2)) (fun v10 : @nat => match v10 as v11 in nat return Prop with | 0 => @False | S v11 => (fun v11 : @nat => @True) v11 end) (@I) 0 v8 in False_ind (@Gt = @Lt) v9) v7 | le_S _ v7 v8 => (fun (v7 : @nat) (v8 : S (S v2) <= v7) (v9 : S v7 = 0) => (fun v10 : S v7 = 0 => let v11 : @False := eq_ind (S v7) (fun v12 : @nat => match v12 as v13 in nat return Prop with | 0 => @False | S v13 => (fun v13 : @nat => @True) v13 end) (@I) 0 v10 in False_ind (forall v12 : S (S v2) <= v7, @Gt = @Lt) v11) v9 v8) v7 v8 end in v6 eq_refl) : (S v2 ?= 0) = @Lt <-> S v2 < 0 | S v5 => (fun v5 : @nat => (fun v6 : (v2 ?= v5) = @Lt <-> v2 < v5 => trans_co_eq_inv_impl_morphism (@iff_Transitive) ((v2 ?= v5) = @Lt) (v2 < v5) v6 (S v2 < S v5) (S v2 < S v5) (eq_proper_proxy (S v2 < S v5))) (v3 v5) (conj (le_n_S (S v2) v5) (le_S_n (S v2) v5)) : (S v2 ?= S v5) = @Lt <-> S v2 < S v5) v5 end) v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.PeanoNat.Nat.compare_le_iff	180	3.175883	2	3	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => nat_ind (fun v2 : @nat => forall v3 : @nat, (v2 ?= v3) <> @Gt <-> v2 <= v3) (fun v2 : @nat => match v2 as v3 in nat return ((0 ?= v3) <> @Gt <-> 0 <= v3) with | 0 => conj (fun v3 : @Eq <> @Gt => le_n 0) (fun v3 : 0 <= 0 => (fun v4 : @Eq = @Gt => let v5 : forall v6 : @Gt = @Gt, @False := match v4 as v7 in (_ = v6) return (forall v8 : v6 = @Gt, @False) with | eq_refl => fun v6 : @Eq = @Gt => (fun v7 : @Eq = @Gt => let v8 : @False := eq_ind (@Eq) (fun v9 : @comparison => match v9 as v10 in comparison return Prop with | Eq => @True | _ => @False end) (@I) (@Gt) v7 in False_ind (@False) v8) v6 end in v5 eq_refl) : @Eq <> @Gt) : (0 ?= 0) <> @Gt <-> 0 <= 0 | S v3 => (fun v3 : @nat => conj (fun v4 : @Lt <> @Gt => le_0_n (S v3)) (fun v4 : 0 <= S v3 => (fun v5 : @Lt = @Gt => let v6 : forall v7 : @Gt = @Gt, @False := match v5 as v8 in (_ = v7) return (forall v9 : v7 = @Gt, @False) with | eq_refl => fun v7 : @Lt = @Gt => (fun v8 : @Lt = @Gt => let v9 : @False := eq_ind (@Lt) (fun v10 : @comparison => match v10 as v11 in comparison return Prop with | Lt => @True | _ => @False end) (@I) (@Gt) v8 in False_ind (@False) v9) v7 end in v6 eq_refl) : @Lt <> @Gt) : (0 ?= S v3) <> @Gt <-> 0 <= S v3) v3 end) (fun (v2 : @nat) (v3 : forall v4 : @nat, (v2 ?= v4) <> @Gt <-> v2 <= v4) (v4 : @nat) => match v4 as v5 in nat return ((S v2 ?= v5) <> @Gt <-> S v2 <= v5) with | 0 => conj (fun v5 : @Gt <> @Gt => let v6 : @False := v5 eq_refl in match v6 as v7 in False return (S v2 <= 0) with end) (fun v5 : S v2 <= 0 => let v6 : forall v7 : 0 = 0, @Gt <> @Gt := match v5 as v8 in (_ <= v7) return (forall v9 : v7 = 0, @Gt <> @Gt) with | le_n _ => fun v7 : S v2 = 0 => (fun v8 : S v2 = 0 => let v9 : @False := eq_ind (S v2) (fun v10 : @nat => match v10 as v11 in nat return Prop with | 0 => @False | S v11 => (fun v11 : @nat => @True) v11 end) (@I) 0 v8 in False_ind (@Gt <> @Gt) v9) v7 | le_S _ v7 v8 => (fun (v7 : @nat) (v8 : S v2 <= v7) (v9 : S v7 = 0) => (fun v10 : S v7 = 0 => let v11 : @False := eq_ind (S v7) (fun v12 : @nat => match v12 as v13 in nat return Prop with | 0 => @False | S v13 => (fun v13 : @nat => @True) v13 end) (@I) 0 v10 in False_ind (forall v12 : S v2 <= v7, @Gt <> @Gt) v11) v9 v8) v7 v8 end in v6 eq_refl) : (S v2 ?= 0) <> @Gt <-> S v2 <= 0 | S v5 => (fun v5 : @nat => (fun v6 : (v2 ?= v5) <> @Gt <-> v2 <= v5 => trans_co_eq_inv_impl_morphism (@iff_Transitive) ((v2 ?= v5) <> @Gt) (v2 <= v5) v6 (S v2 <= S v5) (S v2 <= S v5) (eq_proper_proxy (S v2 <= S v5))) (v3 v5) (conj (fun v6 : v2 <= v5 => le_n_S v2 v5 v6) (fun v6 : S v2 <= S v5 => le_S_n v2 v5 v6)) : (S v2 ?= S v5) <> @Gt <-> S v2 <= S v5) v5 end) v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.PeanoNat.Nat.compare_antisym	180	3.087639	2	3	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => nat_ind (fun v2 : @nat => forall v3 : @nat, (v3 ?= v2) = CompOpp (v2 ?= v3)) (fun v2 : @nat => match v2 as v3 in nat return ((v3 ?= 0) = CompOpp (0 ?= v3)) with | 0 => eq_refl : (0 ?= 0) = CompOpp (0 ?= 0) | S v3 => (fun v3 : @nat => eq_refl : (S v3 ?= 0) = CompOpp (0 ?= S v3)) v3 end) (fun (v2 : @nat) (v3 : forall v4 : @nat, (v4 ?= v2) = CompOpp (v2 ?= v4)) (v4 : @nat) => match v4 as v5 in nat return ((v5 ?= S v2) = CompOpp (S v2 ?= v5)) with | 0 => eq_refl : (0 ?= S v2) = CompOpp (S v2 ?= 0) | S v5 => (fun v5 : @nat => v3 v5 : (S v5 ?= S v2) = CompOpp (S v2 ?= S v5)) v5 end) v0 v1)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.PeanoNat.Nat.compare_succ	180	2.916313	2	3	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 v1 : @nat => eq_refl)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.PeanoNat.Nat.max_l	180	2.986144	1	2	0	synth with cache (only 1: refine @max_l).
coq-tactician-stdlib.8.11.dev	Coq.Arith.PeanoNat.Nat.max_r	180	3.019460	1	2	0	synth with cache (only 1: refine @max_r).
coq-tactician-stdlib.8.11.dev	Coq.Arith.PeanoNat.Nat.min_l	180	3.339874	1	2	0	synth with cache (only 1: refine @min_l).
coq-tactician-stdlib.8.11.dev	Coq.Arith.PeanoNat.Nat.min_r	180	3.308979	1	2	0	synth with cache (only 1: refine @min_r).
coq-tactician-stdlib.8.11.dev	Coq.Arith.PeanoNat.Nat.pow_neg_r	180	4.062088	2	3	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : @nat) (v2 : v1 < 0) => let v3 : forall v4 : 0 = 0, v0 ^ v1 = 0 := match v2 as v5 in (_ <= v4) return (forall v6 : v4 = 0, v0 ^ v1 = 0) with | le_n _ => fun v4 : S v1 = 0 => (fun v5 : S v1 = 0 => let v6 : @False := eq_ind (S v1) (fun v7 : @nat => match v7 as v8 in nat return Prop with | 0 => @False | S v8 => (fun v8 : @nat => @True) v8 end) (@I) 0 v5 in False_ind (v0 ^ v1 = 0) v6) v4 | le_S _ v4 v5 => (fun (v4 : @nat) (v5 : S v1 <= v4) (v6 : S v4 = 0) => (fun v7 : S v4 = 0 => let v8 : @False := eq_ind (S v4) (fun v9 : @nat => match v9 as v10 in nat return Prop with | 0 => @False | S v10 => (fun v10 : @nat => @True) v10 end) (@I) 0 v7 in False_ind (forall v9 : S v1 <= v4, v0 ^ v1 = 0) v8) v6 v5) v4 v5 end in v3 Logic.eq_refl)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.PeanoNat.Nat.pow_0_r	180	3.871727	2	3	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @nat => Logic.eq_refl)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.PeanoNat.Nat.pow_succ_r	180	3.762488	2	3	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun (v0 v1 : @nat) (v2 : 0 <= v1) => Logic.eq_refl)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.PeanoNat.Nat.square_spec	180	3.755886	2	3	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @nat => Logic.eq_refl)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.PeanoNat.Nat.Private_Parity.Even_1	180	3.824327	1	2	0	synth with cache (only 1: refine ((fun v0 : Even 1 => match v0 as v1 in (ex _) return (@False) with | ex_intro _ v1 v2 => (fun v1 : @nat => match v1 as v2 in nat return (forall v3 : 1 = 2 * v2, @False) with | 0 => fun v2 : 1 = 2 * 0 => let v3 : @False := eq_ind 1 (fun v4 : @nat => match v4 as v5 in nat return Prop with | 0 => @False | S v5 => (fun v5 : @nat => @True) v5 end) (@I) (2 * 0) v2 in False_ind (@False) v3 | S v2 => (fun (v2 : @nat) (v3 : 1 = 2 * S v2) => let v4 : 1 = S (S (v2 + (v2 + 0))) := eq_ind_r (fun v5 : @nat => 1 = S v5) v3 (plus_n_Sm v2 (v2 + 0)) in let v5 : forall v6 : S (S (v2 + (v2 + 0))) = S (S (v2 + (v2 + 0))), @False := match v4 as v7 in (_ = v6) return (forall v8 : v6 = S (S (v2 + (v2 + 0))), @False) with | Logic.eq_refl => fun v6 : 1 = S (S (v2 + (v2 + 0))) => (fun v7 : 1 = S (S (v2 + (v2 + 0))) => let v8 : @False := eq_ind 1 (fun v9 : @nat => match v9 as v10 in nat return Prop with | 0 => @False | S v10 => (fun v10 : @nat => match v10 as v11 in nat return Prop with | 0 => @True | S v11 => (fun v11 : @nat => @False) v11 end) v10 end) (@I) (S (S (v2 + (v2 + 0)))) v7 in False_ind (@False) v8) v6 end in v5 Logic.eq_refl) v2 end) v1 v2 end) : ~ Even 1)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.PeanoNat.Nat.Private_Parity.Even_2	180	3.840660	2	3	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @nat => conj (fun v1 : Even v0 => match v1 as v2 in (ex _) return (Even (S (S v0))) with | ex_intro _ v2 v3 => (fun (v2 : @nat) (v3 : v0 = 2 * v2) => ex_intro (fun v4 : @nat => S (S v0) = 2 * v4) (S v2) (eq_ind_r (fun v4 : @nat => S (S v4) = 2 * S v2) (eq_ind_r (fun v4 : @nat => S v4 = S (v2 + S (v2 + 0))) Logic.eq_refl (plus_n_Sm v2 (v2 + 0)) : S (S (2 * v2)) = 2 * S v2) v3)) v2 v3 end) (fun v1 : Even (S (S v0)) => match v1 as v2 in (ex _) return (Even v0) with | ex_intro _ v2 v3 => (fun (v2 : @nat) (v3 : S (S v0) = 2 * v2) => match v2 as v4 in nat return (forall v5 : S (S v0) = 2 * v4, Even v0) with | 0 => fun v4 : S (S v0) = 2 * 0 => let v5 : @False := eq_ind (S (S v0)) (fun v6 : @nat => match v6 as v7 in nat return Prop with | 0 => @False | S v7 => (fun v7 : @nat => @True) v7 end) (@I) (2 * 0) v4 in False_ind (Even v0) v5 | S v4 => (fun (v4 : @nat) (v5 : S (S v0) = 2 * S v4) => ex_intro (fun v6 : @nat => v0 = 2 * v6) v4 (let v6 : S (S v0) = S (S (v4 + (v4 + 0))) := eq_ind_r (fun v7 : @nat => S (S v0) = S v7) v5 (plus_n_Sm v4 (v4 + 0)) in let v7 : forall v8 : S (S (v4 + (v4 + 0))) = S (S (v4 + (v4 + 0))), v0 = 2 * v4 := match v6 as v9 in (_ = v8) return (forall v10 : v8 = S (S (v4 + (v4 + 0))), v0 = 2 * v4) with | Logic.eq_refl => fun v8 : S (S v0) = S (S (v4 + (v4 + 0))) => (fun v9 : S (S v0) = S (S (v4 + (v4 + 0))) => let v10 : v0 = v4 + (v4 + 0) := f_equal (fun v11 : @nat => match v11 as v12 in nat return (@nat) with | 0 => v0 | S v12 => (fun v12 : @nat => match v12 as v13 in nat return (@nat) with | 0 => v0 | S v13 => (fun v13 : @nat => v13) v13 end) v12 end) v9 in (fun v11 : v0 = v4 + (v4 + 0) => let v12 : v0 = v4 + (v4 + 0) := v11 in eq_ind_r (fun v13 : @nat => v13 = 2 * v4) Logic.eq_refl v12) v10) v8 end in v7 Logic.eq_refl)) v4 end v3) v2 v3 end))).
coq-tactician-stdlib.8.11.dev	Coq.Arith.PeanoNat.Nat.Private_Parity.Odd_0	180	3.823939	1	2	0	synth with cache (only 1: refine ((fun v0 : Odd 0 => match v0 as v1 in (ex _) return (@False) with | ex_intro _ v1 v2 => (fun (v1 : @nat) (v2 : 0 = 2 * v1 + 1) => match v1 as v3 in nat return (forall v4 : 0 = 2 * v3 + 1, @False) with | 0 => fun v3 : 0 = 2 * 0 + 1 => let v4 : forall v5 : 2 * 0 + 1 = 2 * 0 + 1, @False := match v3 as v6 in (_ = v5) return (forall v7 : v5 = 2 * 0 + 1, @False) with | Logic.eq_refl => fun v5 : 0 = 2 * 0 + 1 => (fun v6 : 0 = 2 * 0 + 1 => let v7 : @False := eq_ind 0 (fun v8 : @nat => match v8 as v9 in nat return Prop with | 0 => @True | S v9 => (fun v9 : @nat => @False) v9 end) (@I) (2 * 0 + 1) v6 in False_ind (@False) v7) v5 end in v4 Logic.eq_refl | S v3 => (fun (v3 : @nat) (v4 : 0 = 2 * S v3 + 1) => let v5 : forall v6 : 2 * S v3 + 1 = 2 * S v3 + 1, @False := match v4 as v7 in (_ = v6) return (forall v8 : v6 = 2 * S v3 + 1, @False) with | Logic.eq_refl => fun v6 : 0 = 2 * S v3 + 1 => (fun v7 : 0 = 2 * S v3 + 1 => let v8 : @False := eq_ind 0 (fun v9 : @nat => match v9 as v10 in nat return Prop with | 0 => @True | S v10 => (fun v10 : @nat => @False) v10 end) (@I) (2 * S v3 + 1) v7 in False_ind (@False) v8) v6 end in v5 Logic.eq_refl) v3 end v2) v1 v2 end) : ~ Odd 0)).
coq-tactician-stdlib.8.11.dev	Coq.Arith.PeanoNat.Nat.Private_Parity.Odd_2	180	3.943340	2	3	0.0	synth with cache (only 1: repeat match goal with | H:_ |- _ => revert H end; only 1: refine (fun v0 : @nat => conj (fun v1 : Odd v0 => match v1 as v2 in (ex _) return (Odd (S (S v0))) with | ex_intro _ v2 v3 => (fun (v2 : @nat) (v3 : v0 = 2 * v2 + 1) => ex_intro (fun v4 : @nat => S (S v0) = 2 * v4 + 1) (S v2) (eq_ind_r (fun v4 : @nat => S (S v4) = 2 * S v2 + 1) (eq_ind (S (v2 + (v2 + 0))) (fun v4 : @nat => S (S (v2 + (v2 + 0) + 1)) = S (v4 + 1)) Logic.eq_refl (v2 + S (v2 + 0)) (plus_n_Sm v2 (v2 + 0)) : S (S (2 * v2 + 1)) = 2 * S v2 + 1) v3)) v2 v3 end) (fun v1 : Odd (S (S v0)) => match v1 as v2 in (ex _) return (Odd v0) with | ex_intro _ v2 v3 => (fun (v2 : @nat) (v3 : S (S v0) = 2 * v2 + 1) => match v2 as v4 in nat return (forall v5 : S (S v0) = 2 * v4 + 1, Odd v0) with | 0 => fun v4 : S (S v0) = 2 * 0 + 1 => let v5 : @False := eq_ind (S (S v0)) (fun v6 : @nat => match v6 as v7 in nat return Prop with | 0 => @False | S v7 => (fun v7 : @nat => match v7 as v8 in nat return Prop with | 0 => @False | S v8 => (fun v8 : @nat => @True) v8 end) v7 end) (@I) (2 * 0 + 1) v4 in False_ind (Odd v0) v5 | S v4 => (fun (v4 : @nat) (v5 : S (S v0) = 2 * S v4 + 1) => ex_intro (fun v6 : @nat => v0 = 2 * v6 + 1) v4 (let v6 : S (S v0) = S (S (v4 + S (v4 + 0) + 0)) := eq_ind_r (fun v7 : @nat => S (S v0) = S v7) v5 (plus_n_Sm (v4 + S (v4 + 0)) 0) in let v7 : forall v8 : S (S (v4 + S (v4 + 0) + 0)) = S (S (v4 + S (v4 + 0) + 0)), v0 = 2 * v4 + 1 := match v6 as v9 in (_ = v8) return (forall v10 : v8 = S (S (v4 + S (v4 + 0) + 0)), v0 = 2 * v4 + 1) with | Logic.eq_refl => fun v8 : S (S v0) = S (S (v4 + S (v4 + 0) + 0)) => (fun v9 : S (S v0) = S (S (v4 + S (v4 + 0) + 0)) => let v10 : v0 = v4 + S (v4 + 0) + 0 := f_equal (fun v11 : @nat => match v11 as v12 in nat return (@nat) with | 0 => v0 | S v12 => (fun v12 : @nat => match v12 as v13 in nat return (@nat) with | 0 => v0 | S v13 => (fun v13 : @nat => v13) v13 end) v12 end) v9 in (fun v11 : v0 = v4 + S (v4 + 0) + 0 => let v12 : v0 = v4 + S (v4 + 0) + 0 := v11 in eq_ind_r (fun v13 : @nat => v13 = 2 * v4 + 1) (eq_ind (S (v4 + (v4 + 0))) (fun v13 : @nat => v13 + 0 = v4 + (v4 + 0) + 1) (eq_ind (S (v4 + (v4 + 0) + 0)) (fun v13 : @nat => S (v4 + (v4 + 0)) + 0 = v13) (eq_ind (S (v4 + (v4 + 0))) (fun v13 : @nat => v13 = S (v4 + (v4 + 0) + 0)) (eq_ind v4 (fun v13 : @nat => S (v4 + v13) = S (v4 + v13 + 0)) (eq_ind (v4 + v4) (fun v13 : @nat => S (v4 + v4) = S v13) Logic.eq_refl (v4 + v4 + 0) (plus_n_O (v4 + v4))) (v4 + 0) (plus_n_O v4)) (S (v4 + (v4 + 0)) + 0) (plus_n_O (S (v4 + (v4 + 0))))) (v4 + (v4 + 0) + 1) (plus_n_Sm (v4 + (v4 + 0)) 0)) (v4 + S (v4 + 0)) (plus_n_Sm v4 (v4 + 0)) : v4 + S (v4 + 0) + 0 = 2 * v4 + 1) v12) v10) v8 end in v7 Logic.eq_refl)) v4 end v3) v2 v3 end))).
coq-tactician-stdlib.8.11.dev	Coq.Arith.PeanoNat.Nat.even_spec	180
coq-tactician-stdlib.8.11.dev	Coq.Arith.PeanoNat.Nat.odd_spec	180
